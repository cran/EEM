#' Find local maximum peaks
#' 
#' Find local maximum peaks in EEM data
#' 
#' @param data EEM data generated by \code{\link{readEEM}} function, or a matrix or dataframe with 
#' columns = excitation and rows = emission wavelengths.
#' @param n sample number. The number should not exceed \code{length(EEM)}.
#' @param threshold threshold value ranging from 0 ~ 1. Lower the value to cover low peaks.
#' @param ... (optional) further arguments passed to other methods
#' 
#' @return A dataframe of local maximum peaks
#' 
#' @examples
#' data(applejuice)
#' findLocalMax(applejuice, 1) 
#' 
#' @export
#' 
#' @importFrom reshape2 melt
#' @importFrom sp point.in.polygon
#' @importFrom grDevices contourLines
#' 
findLocalMax <- function(data, ...) UseMethod("findLocalMax", data)

#' @describeIn findLocalMax for EEM data created by \code{\link{readEEM}} function
#' @export
findLocalMax.EEM <- function(data, n, threshold = 0.7, ...){
    
        # make sure that n is given
        if (nargs() < 2) stop('Require at least 2 arguments')
    
        # get information from EEM
        data <- data[[n]]
        
        # calculate for regional max
        local_max <- findLocalMax.matrix(data, threshold = threshold)
        return(local_max)
}

#' @describeIn findLocalMax for a matrix with columns being 
#' excitation wavelength and rows being emission wavelength
#' @export
findLocalMax.matrix <- function(data, threshold = 0.7, ...){
    
    # get contourLines
    x <- as.numeric(colnames(data)) # EX
    y <- as.numeric(rownames(data)) # EM
    z <- t(as.matrix(data))
    cLine <- contourLines(x, y, z, nlevels = 100) 
    
    # melt z
    z_melted <- melt(z)
    names(z_melted)[1:2] <- c("EX", "EM")
    
    # retrieve high contours
    level <- sapply(cLine, function(x) x$level)
    dif <- diff(range(level))
    cutoff <- dif * threshold
    value <- min(level[level > cutoff])
    cLine_selected <- cLine[level == value]
    
    # find max value for each contour
    local_max <- data.frame(EX = numeric(), EM = numeric(), value = numeric(), 
                            stringsAsFactors = FALSE)
    I <- length(cLine_selected)
    for (i in 1:I) {
        pol <- cLine_selected[i]
        pol.x <- as.numeric(sapply(pol, function(x) x$x))
        pol.y <- as.numeric(sapply(pol, function(x) x$y))
        index <- point.in.polygon(z_melted$EX, z_melted$EM, pol.x, pol.y) > 0
        if (sum(index) == 0){ 
            # when there is no real point within polygon, give NA value
            local_max[i,] <- NA
        } else {
            MAX <- max(z_melted$value[index])
            MAX.index <- which(z_melted$value == MAX)
            local_max[i,] <- z_melted[MAX.index,]
        }
    }
    row.names(local_max) <- NULL
    return(local_max)
}

#' @describeIn findLocalMax for a dataframe with columns being 
#' excitation wavelength and rows being emission wavelength
#' @export
findLocalMax.data.frame <- function(data, threshold = 0.7, ...){
    
    # dataframe to matrix
    data <- as.matrix(data)
    
    # calculate for regional max
    local_max <- findLocalMax.matrix(data, threshold = threshold)
    return(local_max)
}

#' @describeIn findLocalMax for a vector of numeric values which have names in 
#' the format of EX...EM...
#' @export
findLocalMax.numeric <- function(data, threshold = 0.7, ...){

    # convert data to matrix form
    name <- names(data)
    EX <- getEX(name)
    EM <- getEM(name)
    data <- data.frame(ex = as.numeric(EX), em = as.numeric(EM), value = data)
    data.casted <- acast(data, em ~ ex, value.var = "value")
    
    # calculate for regional max
    local_max <- findLocalMax.matrix(data.casted, threshold = threshold)
    return(local_max)
}